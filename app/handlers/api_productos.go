/*
 * API for INVINOS blockchain broker
 *
 * Esta es la API para el brocker de INVINOS con el que hay que interactuar para realizar transacciones en la blockchain.
 *
 * API version: 1.0
 * Contact: francisco.delicado@uclm.es
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package handlers

import (
	"context"
	"encoding/json"
	"github.com/swarleynunez/INVINOS/app/models"
	"github.com/swarleynunez/INVINOS/core"
	"github.com/swarleynunez/INVINOS/core/utils"
	"net/http"
	"strings"
)

func ProductEntryPost(w http.ResponseWriter, r *http.Request) {

	// Get POST parameters
	var e models.Entrada
	err := json.NewDecoder(r.Body).Decode(&e)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if e.Fecha == "" ||
		e.Producto.Cantidad.Valor == 0 ||
		e.Producto.Tipo == "" ||
		e.Vendedor.Id == "" ||
		e.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Manage POST certificate files (composition certificates)
	err = core.CheckForCompositionCertificates(context.Background(), &e.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Manage POST certificate files (product certificates)
	err = core.CheckForProductCertificates(context.Background(), &e.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Get API token from request
	token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
	tinst, einst, _ := core.GetContractInstances(token)

	// Blockchain interaction
	err = core.ProductEntryTxn(tinst, einst, e.Producto.Cantidad.Valor, e.Producto.Tipo, e.Vendedor.Id, e.AContenedor.Id, utils.MarshalJSON(e))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductProcessingPost(w http.ResponseWriter, r *http.Request) {

	// Get POST parameters
	var p models.Procesado
	err := json.NewDecoder(r.Body).Decode(&p)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if p.Fecha == "" || p.Producto.Id == 0 || p.Producto.Tipo == "" || p.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Manage POST certificate files (composition certificates)
	err = core.CheckForCompositionCertificates(context.Background(), &p.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Manage POST certificate files (product certificates)
	err = core.CheckForProductCertificates(context.Background(), &p.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Get API token from request
	token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
	tinst, einst, _ := core.GetContractInstances(token)

	// Blockchain interaction
	err = core.ProductProcessingTxn(tinst, einst, p.Producto.Id, p.Merma.Valor, p.Producto.Tipo, p.AContenedor.Id, utils.MarshalJSON(p))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductPartitionPost(w http.ResponseWriter, r *http.Request) {

	// Get POST parameters
	var p models.Particion
	err := json.NewDecoder(r.Body).Decode(&p)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if p.Fecha == "" || p.Producto.Id == 0 || p.Cantidad.Valor == 0 || p.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Manage POST certificate files (composition certificates)
	err = core.CheckForCompositionCertificates(context.Background(), &p.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Manage POST certificate files (product certificates)
	err = core.CheckForProductCertificates(context.Background(), &p.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Get API token from request
	token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
	tinst, einst, _ := core.GetContractInstances(token)

	// Blockchain interaction
	err = core.ProductPartitionTxn(tinst, einst, p.Producto.Id, p.Cantidad.Valor, p.AContenedor.Id, utils.MarshalJSON(p))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductOutputPost(w http.ResponseWriter, r *http.Request) {

	// Get POST parameters
	var s models.Salida
	err := json.NewDecoder(r.Body).Decode(&s)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if s.Fecha == "" ||
		s.Producto.Producto.Id == 0 ||
		s.Producto.Lote.NumLote == "" ||
		s.Comprador.Id == "" ||
		s.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Manage POST certificate files (composition certificates)
	err = core.CheckForCompositionCertificates(context.Background(), &s.Producto.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Manage POST certificate files (product certificates)
	err = core.CheckForProductCertificates(context.Background(), &s.Producto.Producto.Info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Get API token from request
	token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
	tinst, einst, _ := core.GetContractInstances(token)

	// Blockchain interaction
	err = core.ProductOutputTxn(tinst, einst, s.Producto.Producto.Id, s.Producto.Lote.NumLote, s.Comprador.Id, s.AContenedor.Id, utils.MarshalJSON(s))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}
