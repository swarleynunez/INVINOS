/*
 * API for INVINOS blockchain broker
 *
 * Esta es la API para el brocker de INVINOS con el que hay que interactuar para realizar transacciones en la blockchain.
 *
 * API version: 1.0
 * Contact: francisco.delicado@uclm.es
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package handlers

import (
	"encoding/json"
	"github.com/swarleynunez/INVINOS/api/models"
	"github.com/swarleynunez/INVINOS/core"
	"github.com/swarleynunez/INVINOS/core/utils"
	"net/http"
)

func ProductEntryPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Get POST parameters
	var e models.Entrada
	err := json.NewDecoder(r.Body).Decode(&e)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if e.Fecha == "" ||
		e.Producto.Cantidad.Valor == 0 ||
		e.Producto.Tipo == "" ||
		e.Vendedor.Id == "" ||
		e.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Blockchain interaction
	err = core.ProductEntryTxn(e.Producto.Cantidad.Valor, e.Producto.Tipo, e.Vendedor.Id, e.AContenedor.Id, utils.MarshalJSON(e))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductProcessingPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Get POST parameters
	var p models.Procesado
	err := json.NewDecoder(r.Body).Decode(&p)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if p.Fecha == "" || p.Producto.Id == 0 || p.Producto.Tipo == "" || p.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Blockchain interaction
	err = core.ProductProcessingTxn(p.Producto.Id, p.Merma.Valor, p.Producto.Tipo, p.AContenedor.Id, utils.MarshalJSON(p))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductPartitionPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Get POST parameters
	var p models.Particion
	err := json.NewDecoder(r.Body).Decode(&p)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if p.Fecha == "" || p.Producto.Id == 0 || p.Cantidad.Valor == 0 || p.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Blockchain interaction
	err = core.ProductPartitionTxn(p.Producto.Id, p.Cantidad.Valor, p.AContenedor.Id, utils.MarshalJSON(p))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}

func ProductOutputPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Get POST parameters
	var s models.Salida
	err := json.NewDecoder(r.Body).Decode(&s)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Parameter checking zone
	if s.Fecha == "" ||
		s.Producto.Producto.Id == 0 ||
		s.Producto.Lote.NumLote == "" ||
		s.Comprador.Id == "" ||
		s.AContenedor.Id == "" {
		w.WriteHeader(http.StatusBadRequest)
		utils.CheckError(ErrMissingParameters, utils.WarningMode)
		return
	}

	// Blockchain interaction
	err = core.ProductOutputTxn(s.Producto.Producto.Id, s.Producto.Lote.NumLote, s.Comprador.Id, s.AContenedor.Id, utils.MarshalJSON(s))
	if err != nil {
		w.WriteHeader(http.StatusConflict)
		utils.CheckError(err, utils.WarningMode)
		return
	}

	// Successful request
	w.WriteHeader(http.StatusOK)
}
